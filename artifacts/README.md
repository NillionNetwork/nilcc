# Artifacts

This directory contains all the artifacts that are required to run a CVM in nilcc. The artifacts in here are split into 
2: the ones used in the host machine, and the ones used in the CVM.

Make sure to read the [parent README file](../README.md) to understand the different components involved in booting a 
CVM before reading this file.

## Host

The host setup requires:

* Compiling a kernel with AMD SEV/SNP support.
* Compiling qemu with AMD SEV/SNP support.
* Setting up the necessary BIOS settings.
* Installing the right nvidia drivers if GPU support is required.

In this repository, only the kernel and qemu compilation steps are addressed.

### Kernel

The kernel used in the host machine can be built by running:

```bash
./kernel/build.sh host
```

This will use a patched version of a linux kernel that supports AMD SEV/SNP and can therefore be used in the baremetal 
machine that runs CVMs.

### QEMU

QEMU with AMD SEV/SNP support can be built by running:

```bash
./qemu/build.sh
```

This will create a single `tar.gz` file that will contain all output artifacts for the QEMU build including its 
binaries, the OVMF to be used, etc.

## Guest

The guest setup is composed of various steps:

### Kernel

Similar to the host kernel, the guest kernel can be built by running the following command:

```bash
./kernel/build.sh guest
```

### initramfs

The initramfs can be built by running:

```bash
./initramfs/build.sh
```

### Base VM disk image

A base VM disk image can be created by running:

```bash
./vm_image/build.sh <cpu|gpu>
```

This will take some time but in the end will generate:

* A `.squashfs` file that contains the raw disk image for the VM, in squashfs format.
* A file that contains the verity hash device and another one that contains the root hash. See more about this 
[here](../README.md#dm-verity)

It is very important to note that all 3 files work in tandem: you cannot take one of the files from one build and the 
other 2 from another one. Doing this will otherwise cause the CVM boot to fail.

## Build artifacts

While every build step generates files under a `build` directory, all scripts will copy over the final artifacts into 
`./dist`.

### Public releases

All artifacts are also uploaded to an [s3 bucket](https://nilcc.s3.eu-west-1.amazonaws.com/) every time a change is 
merged which modifies any of them.

## Release process

The release process here involves splitting artifacts into 2 sets: 

* Those considered "core": the host/guest kernels and qemu.
* The rest of them: the CVM disk images and the initrd file.

This split is done because the first set takes around ~50 minutes to build and very rarely changes, while the second set 
takes ~8 minutes and changes very often. This allows us to only once build the portion of the artifact that rarely 
changes, and have the second half reuse those builds and only build the more often modified components.

### Core artifacts

Core artifacts are built and pushed to S3 whenever anything under `artifacts/core` changes, and every time a tag like 
`nilcc-core-artifacts-X.Y.Z` is pushed. These will be uploaded to s3 under `${version}/core` where `$version` is the 
semver `X.Y.Z` version if a tag was pushed, or the git hash it's just a `main` branch merge.

Along with these, a `core/metadata.json` file is pushed that includes metadata about the build: the git hashes used, the 
paths for files, and the hashes of those files. This is generated by the file `artifacts/core/generate-metadata.sh`.

### Artifacts

The rest of the artifacts are similarly built if anything changes on them or if a tag like `nilcc-artifacts-X.Y.Z` is 
pushed and are uploaded to S3 under `${version}` following the same logic as above for what `$version` means.

As part of the artifacts build, a specific build of the core artifacts is downloaded and is also uploaded at the end of 
the build. This means that an artifact build "includes" both the artifacts and the core ones in whatever path they're 
uploaded in S3. This allows us to split the build only for CI speedup purposes but the end result is the same for anyone 
using a concrete artifact version build.
